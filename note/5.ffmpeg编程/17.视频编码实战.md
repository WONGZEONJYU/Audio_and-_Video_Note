# 1. FFmpeg流程

<img src="./assets/image-20240330213527952.png" alt="image-20240330213527952" /> 

从本地读取YUV数据编码为h264格式的数据 , 然后再存⼊到本地 , 编码后的数据有带startcode

与FFmpeg 示例⾳频编码的流程基本⼀致

函数说明:

| `avcodec_find_encoder_by_name(...)` | 根据指定的编码器名称查找注册的编码器                         |
| ----------------------------------- | ------------------------------------------------------------ |
| `avcodec_alloc_context3(...)`       | 为AVCodecContext分配内存                                     |
| `avcodec_open2(...)`                | 打开编解码器                                                 |
| `avcodec_send_frame(..)`            | 将AVFrame⾮压缩数据给编码器                                  |
| `avcodec_receive_packet(...)`       | 获取到编码后的AVPacket数据                                   |
| `av_frame_get_buffer(...)`          | 为⾳频或视频数据分配新的buffer , 在调⽤这个函数之前 , 必须在AVFame上设置好以下属性 : <br />format (视频为像素格式 , ⾳频为样本格式)<br />nb_samples (样本个数 , 针对⾳频)<br />channel_layout (通道类型 , 针对⾳频) <br />width / height (宽⾼ , 针对视频) |
| `av_frame_make_writable(...)`       | 确保AVFrame是可写的 , 尽可能避免数据的复制如果AVFrame不是是可写的 , 将分配新的buffer和复制数 |
| `av_image_fill_arrays(...)`         | 存储⼀帧像素数据存储到AVFrame对应的data buffer               |

编码出来的h264数据可以直接使⽤ffplay播放 , 也可以使⽤VLC播放

## 1.1 `av_image_get_buffer_size(...)`

`int av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height, int align);`

函数的作⽤是通过指定像素格式、图像宽、图像⾼来计算所需的内存⼤⼩重点说明⼀个参数align:此参数是设定内存对⻬的对⻬数，也就是按多⼤的字节进⾏内存对⻬：

- ⽐如设置为1,表示按1字节对⻬，那么得到的结果就是与实际的内存⼤⼩⼀样
- 再⽐如设置为4，表示按4字节对⻬。也就是内存的起始地址必须是4的整倍数。

