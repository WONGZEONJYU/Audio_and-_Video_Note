# 1. FFmpeg流程

<img src="./assets/image-20240330213527952.png" alt="image-20240330213527952" /> 

从本地读取YUV数据编码为h264格式的数据 , 然后再存⼊到本地 , 编码后的数据有带startcode

与FFmpeg 示例⾳频编码的流程基本⼀致

函数说明:

| 函数名称                            | 函数作用                                                     |
| ----------------------------------- | ------------------------------------------------------------ |
| `avcodec_find_encoder_by_name(...)` | 根据指定的编码器名称查找注册的编码器                         |
| `avcodec_alloc_context3(...)`       | 为AVCodecContext分配内存                                     |
| `avcodec_open2(...)`                | 打开编解码器                                                 |
| `avcodec_send_frame(..)`            | 将AVFrame⾮压缩数据给编码器                                  |
| `avcodec_receive_packet(...)`       | 获取到编码后的AVPacket数据                                   |
| `av_frame_get_buffer(...)`          | 为⾳频或视频数据分配新的buffer , 在调⽤这个函数之前 , 必须在AVFame上设置好以下属性 : <br />format (视频为像素格式 , ⾳频为样本格式)<br />nb_samples (样本个数 , 针对⾳频)<br />channel_layout (通道类型 , 针对⾳频) <br />width / height (宽⾼ , 针对视频) |
| `av_frame_make_writable(...)`       | 确保AVFrame是可写的 , 尽可能避免数据的复制如果AVFrame不是是可写的 , 将分配新的buffer和复制数 |
| `av_image_fill_arrays(...)`         | 存储⼀帧像素数据存储到AVFrame对应的data buffer               |

编码出来的h264数据可以直接使⽤ffplay播放 , 也可以使⽤VLC播放

## 1.1 `av_image_get_buffer_size(...)`

`int av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height, int align);`

函数的作⽤是通过指定像素格式、图像宽、图像⾼来计算所需的内存⼤⼩重点说明⼀个参数align:此参数是设定内存对⻬的对⻬数 , 也就是按多⼤的字节进⾏内存对⻬ : 

- ⽐如设置为 1 , 表示按1字节对⻬ , 那么得到的结果就是与实际的内存⼤⼩⼀样
- 再⽐如设置为4 , 表示按4字节对⻬ , 也就是内存的起始地址必须是4的整倍数

## 1.2 `av_image_alloc(...)`

> ```c++
> int av_image_alloc(uint8_t* pointers[4], 
>                    int linesizes[4], int w, int h, 
>                    enum AVPixelFormat pix_fmt,
>                    int align);
> ```

`av_image_alloc(...)` 是这样定义的 , 此函数的功能是按照指定的宽、⾼、像素格式来分配图像内存 

| 参数                       | 参数说明                                                     |
| -------------------------- | ------------------------------------------------------------ |
| uint8_t* pointers[4]       | 保存图像通道的地址 , 如果是RGB , 则前三个指针分别指向R,G,B的内存地址 , 第四个指针保留不⽤ |
| int linesizes[4]           | 保存图像每个通道的内存对⻬的步⻓ , 即⼀⾏的对⻬内存的宽度 , 此值⼤⼩等于图像宽度 |
| int w                      | 要申请内存的图像宽度                                         |
| int h                      | 要申请内存的图像⾼度                                         |
| enum AVPixelFormat pix_fmt | 要申请内存的图像的像素格式                                   |
| int align                  | ⽤于内存对⻬的值                                             |

| 返回类型int | 返回值解释                                           |
| ----------- | ---------------------------------------------------- |
| return(int) | 所申请的内存空间的总⼤⼩ , 如果是负值 , 表示申请失败 |

## 1.3 `av_image_fill_arrays(...)`

> ```c++
> int av_image_fill_arrays(uint8_t *dst_data[4],int dst_linesize[4],
>                          const uint8_t *src,
>                          enum AVPixelFormat pix_fmt,
>                          int width,int height,int align);
> ```

`av_image_fill_arrays(...)` 函数⾃身不具备内存申请的功能 , 此函数类似于格式化已经申请的内存 , 即通过 `av_malloc(...)` 函数申请的内存空间 , 或者 `av_frame_get_buffer()` 函数申请的内存空间 , 再者 , `av_image_fill_arrays(...)` 中参数具体说明 : 

| 参数                       | 参数解释                                              |
| -------------------------- | ----------------------------------------------------- |
| uint8_t *dst_data[4]       | [out] 对申请的内存格式化为三个通道后 , 分别保存其地址 |
| int dst_linesize[4]        | [out] 格式化的内存的步⻓ (即内存对⻬后的宽度)         |
| const uint8_t *src         | [in] `av_alloc(...)` 函数申请的内存地址               |
| enum AVPixelFormat pix_fmt | [in] 申请 src内存时的像素格式                         |
| int width                  | [in] 申请src内存时指定的宽度                          |
| int height                 | [in] 申请scr内存时指定的⾼度                          |
| int align                  | [in] 申请src内存时指定的对⻬字节数                    |

# 2. H.264 码率设置

## 2.1 什么是视频码率

- 视频码率是视频数据 (包含视频⾊彩量、亮度量、像素量) 每秒输出的位数 , ⼀般⽤的单位是kbps

## 2.2 设置视频码率的必要性

- 在⽹络视频应⽤中 , 视频质量和⽹络带宽占⽤是相⽭盾的 , 通常情况下 , 视频流占⽤的带宽越⾼则视频质量也越⾼ , 需要的⽹络带宽也越⼤ , 解决这⼀⽭盾的钥匙当然是视频编解码技术 , 评判⼀种视频编解码技术的优劣 , 是⽐较在相同的带宽条件下 , 哪个视频质量更好;在相同的视频质量条件下哪,个占⽤的⽹络带宽更少 (⽂件体积⼩) 
- 是不是视频码率越⾼ , 质量越好呢? 理论上是这样的 , 然⽽在我们⾁眼分辨的范围内 , 当码率⾼到⼀定程度时 , 就没有什么差别了 , 所以码率设置有它的最优值 , H.264 (也叫AVC或X264) 的⽂件中 , 视频的建议码率如下 : 

| 视频大小 | 分辨率    | 推荐码率 |
| -------- | --------- | -------- |
| 480P     | 720X480   | 1800Kbps |
| 720P     | 1280X720  | 3500Kbps |
| 1080P    | 1920X1080 | 8500Kbps |

# 3 . ⼿机设置码率建议

通过上⾯的介绍 , 结合我做过的⼀些⼿机项⽬ , 我总结了⼀套设置码率的公式 , 分享给⼤家如下 :

| 项目     | 计算公式    | 192x144 | 320x240  | 480x360  | 640x480  | 1280x720 | 1920x1080 |
| -------- | ----------- | ------- | -------- | -------- | -------- | -------- | --------- |
| 极低码率 | (宽X⾼X3)/4 | 30kbps  | 60kbps   | 120kbps  | 250kbps  | 500kbps  | 1000kbps  |
| 低码率   | (宽X⾼X3)/2 | 60kbps  | 120kbps  | 250kbps  | 500kbps  | 1000kbps | 2000kbps  |
| 中码率   | (宽X⾼X3)   | 120kbps | 250kbps  | 500kbps  | 1000kbps | 2000kbps | 4000kbps  |
| 高码率   | (宽X⾼X3)X2 | 250kbps | 500kbps  | 1000kbps | 2000kbps | 4000kbps | 8000kbps  |
| 极高码率 | (宽X⾼X3)X4 | 500kbps | 1000kbps | 2000kbps | 4000kbps | 8000kbps | 16000kbps |

