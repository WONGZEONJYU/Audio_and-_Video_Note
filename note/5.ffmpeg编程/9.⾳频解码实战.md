# 1.音频解码过程

音频解码过程如下图所示 : 

<img src="assets/image-20240304101157404.png" alt="image-20240304101157404" /> 

# 2. FFmpeg流程  

<img src="assets/image-20240304101318606.png" alt="image-20240304101318606" /> 

# 3. 关键函数

* `avcodec_find_decoder(...)` : 根据指定的AVCodecID查找注册的解码器。
* `av_parser_init(...) `: 初始化AVCodecParserContext。
* `avcodec_alloc_context3(...)` : 为AVCodecContext分配内存。
* `avcodec_open2(...)` : 打开解码器。
* `av_parser_parse2(...)` : 解析获得⼀个Packet。
* `avcodec_send_packet(...)` : 将AVPacket压缩数据给解码器。
* `avcodec_receive_frame(...)` : 获取到解码后的AVFrame数据。
* `av_get_bytes_per_sample(...)` : 获取每个sample中的字节数  

# 4. 关键数据结构

关键数据结构说明 : 
`AVCodecParser` : ⽤于解析输⼊的数据流并把它分成⼀帧⼀帧的压缩编码数据。比较形象的说法就是把长长的⼀段连续的数据"切割"成⼀段段的数据

比如AAC aac_parser 

ffmpeg-4.2.1\libavcodec\aac_parser.c  

> ```c++
> const AVCodecParser ff_aac_parser = {
>     .codec_ids      = { AV_CODEC_ID_AAC },
>     .priv_data_size = sizeof(AACAC3ParseContext),
>     .parser_init    = aac_parse_init,
>     .parser_parse   = ff_aac_ac3_parse,
>     .parser_close   = ff_parse_close,
> };
> ```

从AVCodecParser结构的实例化我们可以看出来 , 不同编码类型的parser是和CODE_ID进⾏绑定的。所以也就可以解释可以通过CODE_ID查找到对应的码流 parser  

> ```c++
> parser = av_parser_init(codec->id);
> ```

# 5. avcodec编解码API介绍

avcodec_send_packet、avcodec_receive_frame的API是FFmpeg3版本加入的。为了正确的使⽤它们 , 有必要阅读FFmpeg的⽂档说明

[[ffmpeg文档链接]](https://www.ffmpeg.org/doxygen/4.1/group__lavc__encdec.html#details)

FFmpeg提供了两组函数 , 分别⽤于编码和解码 : 

- 解码 : `avcodec_send_packet(...)` 、`avcodec_receive_frame(...)`
- 编码 : `avcodec_send_frame(...)` 、`avcodec_receive_packet(...)`

API的设计与编解码的流程非常贴切

建议的使用流程如下 : 

1. 打开AVCodecContext
2. 输入有效的数据
   - 解码 : 调用 `avcodec_send_packet(...)` 给解码器传入包含原始的压缩数据的 `AVPacket` 对象
   - 编码 : 调⽤ `avcodec_send_frame(...)` 给编码器传入包含解压数据的 `AVFrame` 对象。两种情况下推荐 `AVPacket` 和 `AVFrame`都使用 `refcounted` (引⽤计数) 的模式 , 否则 `libavcodec` 可能不得不对输⼊的数据进行拷贝

3. 在⼀个 **循环体内** 去接收 codec 的输出 , 即周期性地调用 `avcodec_receive_xxx(...)` 来接收 codec 输出的数据
   - 解码 : 调⽤ `avcodec_receive_frame(...)` , 如果成功会返回⼀个包含 **$\color{red}{\mathbf{未压缩}}$** 数据的 `AVFrame`
   - 编码 : 调⽤ `avcodec_receive_packet(...)` , 如果成功会返回⼀个包含 **$\color{red}{\mathbf{压缩}}$** 数据的 `AVPacket`

反复地调用 `avcodec_receive_frame(...)` 或 `avcodec_receive_packet(...)` **$\color{red}{\mathbf直到返回{AVERROR(EAGAIN)}}$ 或其他错误** 返回 **$\color{red}{\mathbf{AVERROR(EAGAIN)}}$** 错误表示codec需要新的输入来输出更多的数据。对于每个输入的 packet 或 frame，codec ⼀般会输出⼀个 `frame` 或 `packet` , 但是也有可能输出0个或者多于1个

4. 流处理结束的时候需要flush (冲刷) codec。因为codec可能在内部缓冲多个 frame 或 packet，出于性能或其他必要的情况(如考虑B帧的情况)  处理流程如下 : 
   - 调⽤ `avcodec_send_xxx(...)` 传入的 `AVFrame` 或 `AVPacket` 指针设置为 `nullptr` 这将进入draining mode (排水模式)
   - 反复地调用 `avcodec_receive_xxx(...)` 直到返回 `AVERROR_EOF`，该方法在 draining mode 时不会返回`AVERROR(EAGAIN)` 的错误，除非你没有进入 draining mode  
   - 当重新开启codec时 , 需要先调用 `avcodec_flush_buffers(...)` 来重置codec  

> ```tex
> 说明:
> 1.编码或者解码刚开始的时候,codec可能接收了多个输⼊的frame或packet后还没有输出数据,直到内部的buffer被填充满。上⾯的使⽤流程可以处理这种情况。
> 2.理论上,只有在输出数据没有被完全接收的情况调⽤avcodec_send_xxx()的时候才可能会发⽣AVERROR(EAGAIN)的错误。你可以依赖这个机制来实现区别于上⾯建议流程的处理⽅式 , ⽐如每次循环都调⽤avcodec_send_*(),在出现AVERROR(EAGAIN)错误的时候再去调⽤avcodec_receive_*()。
> 3.并不是所有的codec都遵循⼀个严格、可预测的数据处理流程,唯⼀可以保证的是 "调⽤avcodec_send_*()/ avcodec_receive_*()返回AVERROR(EAGAIN)的时候去avcodec_receive_*()/avcodec_send_*()会成功,否则不应该返回AVERROR(EAGAIN)的错误" ⼀般来说，任何codec都不允许⽆限制地缓存输⼊或者输出。
> 4.在同⼀个AVCodecContext上混合使⽤新旧API是不允许的,这将导致未定义的⾏为。
> ```

