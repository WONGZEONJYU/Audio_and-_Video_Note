# 1. FFmpeg合成流程  

本程序会生成一个合成的音频和视频流 , 并将它们编码和封装输出到输出文件 , 输出格式是根据文件扩展名自动猜测的 , 流程图如下 : 

<img src="assets/image-20240407155907947.png" alt="image-20240407155907947" />  

ffmpeg 的 Mux 主要分为三步操作 : 

|                                                         |          |
| ------------------------------------------------------- | -------- |
| `avformat_write_header(...)`                            | 写文件头 |
| `av_write_frame(...) / av_interleaved_write_frame(...)` | 写packet |
| `av_write_trailer(...)`                                 | 写文件尾 |

|                                   |                                                              |
| --------------------------------- | ------------------------------------------------------------ |
| `avcodec_parameters_from_context` | 将AVCodecContext结构体中码流参数拷贝到AVCodecParameters结构体中和avcodec_parameters_to_context刚好相反 |

# 2. 用到相关函数

## 2.1 `avformat_write_header(...)`

> ```c++
> int avformat_write_header(AVFormatContext *s,AVDictionary **options);
> ```

| 参数                     | 参数解释                                                     |
| ------------------------ | ------------------------------------------------------------ |
| `AVFormatContext *s`     | 媒体文件句柄 , 必须使用 `avformat_alloc_context(...)` 进行分配 , 其oformat字段必须设置为所需的输出格式;其pb字段必须设置为已经打开的AVIOContext |
| `AVDictionary **options` | 一个包含AVFormatContext和混流器私有选项的AVDictionary , 返回时 , 这个参数将被销毁并替换为一个包含未找到的选项的字典 , 可能为空NULL |

| 返回值 | 返回值解释                                                   |
| ------ | ------------------------------------------------------------ |
| int    | `AVSTREAM_INIT_IN_WRITE_HEADER` 表示在 `avformat_init(...)` 中成功初始化编解码器 (如果编解码器尚未完全初始化), `AVSTREAM_INIT_IN_INIT_OUTPUT` 表示在 `avformat_init(...)` 中成功初始化编解码器 (如果编解码器已经完全初始化) , 失败时返回负 `AVERROR` |

源码实现 : 

> ```c++
> int avformat_write_header(AVFormatContext *s, AVDictionary **options)
> {
>     FFFormatContext *const si = ffformatcontext(s);
>     int already_initialized = si->initialized;
>     int streams_already_initialized = si->streams_initialized;
>     int ret = 0;
> 
>     if (!already_initialized)
>         if ((ret = avformat_init_output(s, options)) < 0)
>             return ret;
> 
>     if (ffofmt(s->oformat)->write_header) {
>         if (!(s->oformat->flags & AVFMT_NOFILE) && s->pb)
>             avio_write_marker(s->pb, AV_NOPTS_VALUE, AVIO_DATA_MARKER_HEADER);
>         ret = ffofmt(s->oformat)->write_header(s);
>         if (ret >= 0 && s->pb && s->pb->error < 0)
>             ret = s->pb->error;
>         if (ret < 0)
>             goto fail;
>         flush_if_needed(s);
>     }
>     if (!(s->oformat->flags & AVFMT_NOFILE) && s->pb)
>         avio_write_marker(s->pb, AV_NOPTS_VALUE, AVIO_DATA_MARKER_UNKNOWN);
> 
>     if (!si->streams_initialized) {
>         if ((ret = init_pts(s)) < 0)
>             goto fail;
>     }
> 
>     return streams_already_initialized;
> 
> fail:
>     deinit_muxer(s);
>     return ret;
> }
> ```

最终调用复用器(muxer)的 `write_header(...)`

例如FLV MP4的muxer

> ```c++
> /*MP4 MUXER*/
> const FFOutputFormat ff_mp4_muxer = {
>     .p.name            = "mp4",
>     .p.long_name       = NULL_IF_CONFIG_SMALL("MP4 (MPEG-4 Part 14)"),
>     .p.mime_type       = "video/mp4",
>     .p.extensions      = "mp4",
>     .priv_data_size    = sizeof(MOVMuxContext),
>     .p.audio_codec     = AV_CODEC_ID_AAC,
>     .p.video_codec     = CONFIG_LIBX264_ENCODER ?
>                          AV_CODEC_ID_H264 : AV_CODEC_ID_MPEG4,
>     .init              = mov_init,
>     .write_header      = mov_write_header,
>     .write_packet      = mov_write_packet,
>     .write_trailer     = mov_write_trailer,
>     .deinit            = mov_free,
> #if FF_API_ALLOW_FLUSH
>     .p.flags           = AVFMT_GLOBALHEADER | AVFMT_ALLOW_FLUSH | AVFMT_TS_NEGATIVE,
> #else
>     .p.flags           = AVFMT_GLOBALHEADER | AVFMT_TS_NEGATIVE,
> #endif
>     .p.codec_tag       = mp4_codec_tags_list,
>     .check_bitstream   = mov_check_bitstream,
>     .p.priv_class      = &mov_isobmff_muxer_class,
>     .flags_internal    = FF_FMT_ALLOW_FLUSH,
> };
> 
> /*FLV MUXER*/
> 
> const FFOutputFormat ff_flv_muxer = {
>     .p.name         = "flv",
>     .p.long_name    = NULL_IF_CONFIG_SMALL("FLV (Flash Video)"),
>     .p.mime_type    = "video/x-flv",
>     .p.extensions   = "flv",
>     .priv_data_size = sizeof(FLVContext),
>     .p.audio_codec  = CONFIG_LIBMP3LAME ? AV_CODEC_ID_MP3 : AV_CODEC_ID_ADPCM_SWF,
>     .p.video_codec  = AV_CODEC_ID_FLV1,
>     .init           = flv_init,
>     .write_header   = flv_write_header,
>     .write_packet   = flv_write_packet,
>     .write_trailer  = flv_write_trailer,
>     .deinit         = flv_deinit,
>     .check_bitstream= flv_check_bitstream,
>     .p.codec_tag    = (const AVCodecTag* const []) {
>                           flv_video_codec_ids, flv_audio_codec_ids, 0
>                       },
>     .p.flags        = AVFMT_GLOBALHEADER | AVFMT_VARIABLE_FPS |
>                       AVFMT_TS_NONSTRICT,
>     .p.priv_class   = &flv_muxer_class,
> };
> ```

## 2.2 `avformat_alloc_output_context2(...)`

> ```c++
> int avformat_alloc_output_context2(AVFormatContext **avctx, 
>                                    const AVOutputFormat *oformat,
>                                    const char *format, 
>                                    const char *filename);
> ```

| 参数                            | 参数说明                                                     |
| ------------------------------- | ------------------------------------------------------------ |
| `AVFormatContext **avctx`       | 需要创建的context , 返回NULL表示失败                         |
| `const AVOutputFormat *oformat` | 指定对应的AVOutputFormat , 如果不指定 , 可以通过后面format_name、filename两个参数进行指定 , 让ffmpeg自己推断 |
| `const char *format`            | 指定音视频的格式 , 比如 "flv" , "mpeg" , "mp4"等 , 如果设置为NULL , 则由filename进行指定 , 让ffmpeg自己推断 |
| `const char *filename`          | 指定音视频文件的路径 , 如果oformat、format_name为NULL , 则ffmpeg内部根据<br/>filename后缀名选择合适的复用器 , 比如xxx.flv则使用flv复用器 |

| 返回值 | 返回值说明                                          |
| ------ | --------------------------------------------------- |
| int    | 成功时返回大于等于0的值 , 失败时返回负的AVERROR代码 |

